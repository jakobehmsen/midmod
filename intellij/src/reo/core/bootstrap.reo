$storeSlot(this, "putSlot/2", (name, value) -> $storeSlot(this, name, value))
Any = this
Any.getSlot(name) => $loadSlot(this, name)
Any.setPrototype(p) => $setPrototype(this, p)

Array = $loadArrayPrototype()
Integer = $loadIntegerPrototype()
Double = $loadDoublePrototype()
String = $loadStringPrototype()
Function = $loadFunctionPrototype()

Collection = #{
    toString() => "I am a collection"
}
Array.setPrototype(Collection)

//$newInstruction("newa", 0)

$loadInstructionPrototype("newa").toString() => "newa"
//Instructions.newa.toString() => "newa"

// Instructions.newa.new()
// Instructions.newa.get()
// Instructions.storeLocal.get(0)
// Instructions.newa.get(#[])
// Instructions.storeLocal.get(#[0])
// Instructions.newa.get(0)
// Instructions.storeLocal.get(1, 0)

// Instructions.loadConst(value) => $newInstruction("loadConst", #[value])
//$newInstruction("storeLocal", #[0])
$newInstruction("newa", #[])
$newInstruction("newa", #[]).toString()

/*
$applyf($newf(#[
    $newInstruction("loadConst", #["Hello World"]),
    $newInstruction("ret", #[])
]), this, #[])
*/

$applyf($newf(#[
    $newInstruction("loadLocal", #[1]),
    $newInstruction("ret", #[])
]), this, #["Hello World"])

myObject = #{
    toString() = $newf(#[
        $newInstruction("loadConst", #["Hello World"]),
        $newInstruction("ret", #[])
    ])
    /*toString(x) = $newf(#[
        $newInstruction("loadLocal", #[1]),
        $newInstruction("ret", #[])
    ])*/
    myMethod() = #{
        apply(receiver, arguments) => "Whatever"
    }
}
myObject.putSlot("toString/1", $newf(#[
   $newInstruction("loadLocal", #[1]),
   $newInstruction("ret", #[])
]))
myObject.toString("Bla bla")
myObject.myMethod()


// It should be possible to enumerate through all instructions and their meta data, such as creation operand count.
// A reflective instruction set.

//#[1, 2, 3].toString()
//#{x = 5 y = 6 toString() => "Whatever"}.toString()